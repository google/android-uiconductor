// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Rectangle class to convert the format between rect need by frontend canvas
 * and one generated by the android xml dumper.
 */
export class Rect {
  constructor(
      public x: number, public y: number, public width: number,
      public height: number) {}
  toString = ():
      string => {
        return `[${this.x},${this.y}][${this.width},${this.height}]`;
      }

  /** Create rect from x1,x2,y1,y2 */
  static createFromCoordinatesStr(coordinates: string) {
    const rect = new Rect(0, 0, 0, 0);
    if (!coordinates || coordinates.length <= 0) {
      return rect;
    }
    // comes in as [startX,startY][endX,endY] in a string
    // returns array in form of:
    // ["", "startX", "startY", "", "endX", "endY", "" ]
    const coordinatesArray = coordinates.split(/[\[\],]/);
    if (coordinatesArray.length !== 7) {
      return rect;
    }

    rect.x = Rect.strToNumber(coordinatesArray[1]);
    rect.y = Rect.strToNumber(coordinatesArray[2]);
    const endX = Rect.strToNumber(coordinatesArray[4]);
    const endY = Rect.strToNumber(coordinatesArray[5]);
    rect.width = endX - rect.x;
    rect.height = endY - rect.y;
    return rect;
  }

  static createFromBoundsStr(coordinates: string) {
    const rect = new Rect(0, 0, 0, 0);
    if (!coordinates || coordinates.length <= 0) {
      return rect;
    }
    // comes in as [startX,startY][width,height] in a string
    // returns array in form of:
    // ["", "startX", "startY", "", "endX", "endY", "" ]
    const coordinatesArray = coordinates.split(/[\[\],]/);
    if (coordinatesArray.length !== 7) {
      return rect;
    }

    rect.x = Rect.strToNumber(coordinatesArray[1]);
    rect.y = Rect.strToNumber(coordinatesArray[2]);
    rect.width = Rect.strToNumber(coordinatesArray[4]);
    rect.height = Rect.strToNumber(coordinatesArray[5]);
    return rect;
  }

  static fromBounds(bounds: Bounds) {
    return new Rect(
        bounds.x1, bounds.y1, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
  }

  // Backend use (x1,y1)(x2,y2), need to do the conversion here
  toBounds() {
    return new Bounds(
        this.x, this.y, this.x + this.width, this.y + this.height);
  }

  contains(r: Rect) {
    return this.x <= r.x && this.y <= r.y &&
        this.x + this.width >= r.x + r.width &&
        this.y + this.height >= r.y + r.height;
  }

  area() {
    return this.width * this.height;
  }

  /**
   * Map current rectangle to the target, for example, (10,20) on a 100*200
   * canvas is actually (100, 300) on a 1000*3000 physical screen.
   * xRatio = 10 / 100 = 0.1
   * x = 10 / 0.1 = 100;
   * The rest fields are similar.
   */
  scaleToTargetSurface(rectSrc: Rect, rectTarget: Rect) {
    const xRatio = rectSrc.width / rectTarget.width;
    const yRatio = rectSrc.height / rectTarget.height;
    const rect = new Rect(
        this.x / xRatio, this.y / yRatio, this.width / xRatio,
        this.height / yRatio);

    return rect;
  }

  static strToNumber(str: string) {
    const val = Number(str);
    if (isNaN(val)) throw new Error('wrong format of coordinate');
    return val;
  }
}

/** Uses (x1,y1)(x2,y2) to represent a rectangle area, matches the backend */
export class Bounds {
  constructor(
      public x1: number, public y1: number, public x2: number,
      public y2: number) {}
  /** Converts to [startX,startY][endX,endY] string format */
  toBoundsStr() {
    return `[${this.x1},${this.y1}][${this.x2},${this.y2}]`;
  }
  toString = ():
      string => {
        return `[${this.x1},${this.y1}][${this.x2},${this.y2}]`;
      }

  getDistanceToOriPoint() {
    return Math.sqrt(this.x1 * this.x1 + this.y1 * this.y1);
  }

  area() {
    return (this.x2 - this.x1) * (this.y2 - this.y1);
  }

  compare(r: Bounds) {
    if (this.getDistanceToOriPoint() < r.getDistanceToOriPoint()) {
      return -1;
    } else if (this.getDistanceToOriPoint() === r.getDistanceToOriPoint()) {
      if (this.area() === r.area()) {
        return 0;
      }
      return this.area() < r.area() ? -1 : 1;
    } else {
      return 1;
    }
  }
}

/** Stores the x,y coordinate on the screen */
export class Point {
  constructor(public x: number, public y: number) {}
  getDistance(targetPoint: Point): number {
    return Math.sqrt(
        (this.x - targetPoint.x) * (this.x - targetPoint.x) +
        (this.y - targetPoint.y) * (this.y - targetPoint.y));
  }
}
